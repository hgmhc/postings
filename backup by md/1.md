# 이진 탐색과 최적해 탐색

[TOC]

## 이진 탐색(Binary Search)

### Definition

**이진 탐색(Binary Search)**은 어떤 수열이 **정렬되어 있을 때, 원하는 값을 빠르게 찾아**내주는 **탐색 알고리즘**입니다.

탐색 알고리즘에는 몇 가지 종류가 더 있지만, 대부분 괄목할 만한 속도 개선은 없고, 이 이진탐색이 가장 구현이 간단하면서 직관적이기에 널리 쓰이고 있습니다.

이진 탐색은 $O(\log n)$시간 내에 원하는 쿼리에 답할 수 있습니다.

### Process

|   $i$    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $arr[i]$ | -94  | -60  | 113  | 137  | 214  | 356  | 430  | 431  |

다음과 같은 테이블에서 원하는 값이 `113` 이라고 합시다.

> 1. (8+1)/2 = `4` 번 인덱스 확인. `113` < `137`
> 1. (3+1)/2 = `2` 번 인덱스 확인. `113` > `-60`
> 1. (3+3)/2 = `3` 번 인덱스 확인. `113` = `113`

$\therefore$ `113` 은 3번 인덱스에 존재합니다!

### Code

두 가지 스타일을 통한 구현이 가능합니다.

첫 번째는 일반적이고, 이해가 더 쉬운 구현입니다.

```C++
int s = 1, e = 8;
while (s <= e) {
    int m = (s+e)/2;
    if (x == arr[m]) {
        //원하는 값을 찾음
    } else if (x < arr[m]) {
        //원하는 값이 더 작음 → 내리기
        b = k-1;
    } else {
        //원하는 값이 더 큼 → 올리기
        a = k+1;
    }
}
```

두 번째는 훨씬 간단한 구현입니다. `lower_bound` 와 같은 값을 출력합니다. 만약 `upper_bound` 를 원한다면 `b` 값의 진행방향을 바꿔야 합니다.

```C++
int m = 1;
for (int b = 8/2; b >= 1; b /= 2)
    while (m+b < n && arr[m+b] <= x) m += b;

if (arr[m] == x) {
    //m자리에 x가 존재함 → 찾음
} else {
    //m자리에 x가 존재하지 않음 → 없음
}
```

### Library

C++ STL을 기준으로,

\<algorithm\> 헤더에  `binary_search` 라는 내장 함수가 존재합니다.

또한,  `lower_bound` 와 `upper_bound` 라는 내장 함수도 존재합니다.

이 둘을 복합적으로 사용할 경우에는 중복된 원소들의 개수까지도 알 수 있습니다. (사실 `equal_range` 라는 함수로 이를 대체할 수 있습니다)

이를 이용하면 [합이 0인 네 정수](https://www.boj.kr/7453)를 간단하게 구현할 수 있습니다.

## 최적해 탐색(Parametric Search)

### Definition

*최적해 탐색은 일반적으로 "파라메트릭 서치"라고 그대로 읽지만 이 글에서는 그 의미를 살려 "최적해 탐색"이라고 명명합니다.

**최적해 탐색(Parametric Search)**는 **최적화 문제를 결정 문제로 바꾼 뒤** 이진 탐색의 아이디어를 통해 빠르게 **최적해를 구해**내는 알고리즘입니다.

### Prerequisites

함수 $ok(x)$의 전제 조건:

$ok(x)$는 $x$라는 인자가 valid할 경우 true, 그렇지 않을 경우 false값을 갖는 함수이다.

이 때, 어떤 $k$에 대해 다음이 만족한다.
$$
ok(x) = [x \geq k]
$$
최적해 탐색을 이용하면 이 $k$의 값을 찾을 수 있다.

최적화 탐색은 이진 탐색을 기반으로 수행되기 때문에 탐색 구간의 길이 $n$을 기준으로, $T(ok(x))\times \log n$시간이 소요된다.



### Process

탐색할 정의역이 $[1,8]$의 자연수들이라고 하자.

|   $x$   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $ok(x)$ |  0   |  0   |  0   |  0   |  1   |  1   |  1   |  1   |

이는 이진 탐색을 이용해 찾아낼 수 있음이 자명하다.

### Code

```C++
int x = 0;
for (int b = 8; b >= 1; b >>= 2)
    while (!ok(x+b)) x += b;
//k = x+1이다.
```

## 덤(Dum)

* 이진 탐색이던, 최적해 탐색이던 둘 다 **병렬 이진 탐색(Parrell Binary Search)**라는 고급 알고리즘을 통해 속도 향상을 꾀할 수 있습니다.