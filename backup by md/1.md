# 이진 탐색과 최적해 탐색

[TOC]

## 이진 탐색(Binary Search)

### Definition

**이진 탐색(Binary Search)**은 어떤 수열이 **정렬되어 있을 때, 원하는 값을 빠르게 찾아**내주는 **탐색 알고리즘**이다.

탐색 알고리즘에는 몇 가지 종류가 더 있지만, 대부분 괄목할 만한 속도 개선은 없고, 이 이진탐색이 가장 구현이 간단하면서 직관적이기에 널리 쓰이고 있다.

이진 탐색은 $O(\log n)$시간 내에 원하는 쿼리에 답할 수 있다.

### Process

|   $i$    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $arr[i]$ | -94  | -60  | 113  | 137  | 214  | 356  | 430  | 431  |

다음과 같은 테이블에서 원하는 값이 `113` 이라고 하자.

> 1. (8+1)/2 = `4` 번 인덱스 확인. `113` < `137`
> 1. (3+1)/2 = `2` 번 인덱스 확인. `113` > `-60`
> 1. (3+3)/2 = `3` 번 인덱스 확인. `113` = `113`

$\therefore$ `113` 은 3번 인덱스에 존재한다.

### Code

두 가지 스타일을 통한 구현이 가능하다.

첫 번째는 일반적이고, 이해가 더 쉬운 구현이다.

```C++
int s = 1, e = 8;
while (s <= e) {
    int m = (s+e)/2;
    if (x == arr[m]) {
        //원하는 값을 찾음
    } else if (x < arr[m]) {
        //원하는 값이 더 작음 → 내리기
        b = k-1;
    } else {
        //원하는 값이 더 큼 → 올리기
        a = k+1;
    }
}
```

두 번째는 훨씬 간단한 구현이다. `lower_bound` 와 같은 값을 출력한다. 만약 `upper_bound` 를 원한다면 `b` 값의 진행방향을 바꿔야 한다.

```C++
int m = 1;
for (int b = 8/2; b >= 1; b /= 2)
    while (m+b < n && arr[m+b] <= x) m += b;

if (arr[m] == x) {
    //m자리에 x가 존재함 → 찾음
} else {
    //m자리에 x가 존재하지 않음 → 없음
}
```

### Library

C++ STL을 기준으로,

\<algorithm\> 헤더에  `binary_search` 라는 내장 함수가 존재한다.

또한,  `lower_bound` 와 `upper_bound` 라는 내장 함수도 존재한다.

이 둘을 복합적으로 사용할 경우에는 중복된 원소들의 개수까지도 알 수 있다. (사실 `equal_range` 라는 함수로 이를 대체할 수 있다)

이를 이용하면 [합이 0인 네 정수](https://www.boj.kr/7453)를 간단하게 구현할 수 있다.

## 최적해 탐색(Parametric Search)

### Definition

*최적해 탐색은 일반적으로 "파라메트릭 서치"라고 그대로 읽지만 이 글에서는 그 의미를 살려 "최적해 탐색"이라고 명명한다.

**최적해 탐색(Parametric Search)**는 **최적화 문제를 결정 문제로 바꾼 뒤** 이진 탐색의 아이디어를 통해 빠르게 **최적해를 구해**내는 알고리즘이다.

### Prerequisites

함수 $ok(x)$의 전제 조건:

$ok(x)$는 $x$라는 인자가 valid할 경우 **true**, 그렇지 않을 경우 **false**값을 갖는 함수이다.

이 때, 어떤 $k$에 대해 다음이 만족한다.
$$
ok(x) = [x \geq k]
$$
최적해 탐색을 이용하면 이 **$\bold{k}$의 값, 즉 최소의 해**를 찾을 수 있다.

또는, $ok(x)$가 어떤 $k$에 대해,
$$
ok(x) = [x \leq k]
$$
를 만족하는 경우에도 최적해 탐색을 통해 $\bold{k}$**의 값, 즉 최대의 해**를 찾아낼 수 있다.

최적화 탐색은 이진 탐색을 기반으로 수행되기 때문에 탐색 구간의 길이 $n$을 기준으로, $T(ok(x))\times \log n$시간이 소요된다.



### Process & Code

탐색할 정의역이 $[1,8]$의 자연수들이라고 하자.

|   $x$   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $ok(x)$ |  0   |  0   |  0   |  0   |  1   |  1   |  1   |  1   |

```C++
int x = 0;
for (int b = 8; b >= 1; b >>= 1)
    while (!ok(x+b)) x += b;
//k = x+1이다.
```
$$
\therefore k = 5
$$

|   $x$   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $ok(x)$ |  1   |  1   |  1   |  1   |  0   |  0   |  0   |  0   |

```C++
int x = 0;
for (int b = 8; b >= 1; b >>= 1)
    while (ok(x+b)) x += b;
//k = x이다.
```

$$
\therefore k = 4
$$

### Problem

* [기타 레슨](boj.kr/2343) 주의할 점은 없다.
* [예산](boj.kr/2512)
* [랜선 자르기](boj.kr/1654), 오버플로우를 주의해야 하는 문제. 하지만 오버플로우가 나도 이상하게 맞아버리는 것을 알 수 있다. 따라서 직접 `ok` 함수에 전달되는 인자를 출력해보며 음수인가 확인해보자.
* [나무 자르기](boj.kr/2805)
* [케이크 자르기](boj.kr/17179)
* [공유기 설치](boj.kr/2110)
* [숫자 구슬](boj.kr/2613) 
* [블록 쌓기](boj.kr/9998)
* [중량제한](boj.kr/1939)
* [전봇대](boj.kr/8986)
* [Thread Knots](bok.kr/17976)
* [Base n](atcoder.jp/contests/abc192/tasks/abc192_d)
* [AGGRCOW - Aggressive cows](spoj.com/problems/AGGRCOW/)

## 덤(Dum)

* 이진 탐색이던, 최적해 탐색이던 둘 다 **병렬 이진 탐색(Parrell Binary Search)**라는 고급 알고리즘을 통해 속도 향상을 꾀할 수 있다.
